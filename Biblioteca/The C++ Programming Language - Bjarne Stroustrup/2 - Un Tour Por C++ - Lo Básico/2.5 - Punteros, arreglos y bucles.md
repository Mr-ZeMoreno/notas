---
anterior: "[[2.4 - Pruebas y bucles]]"
siguiente: "[[3 - Tipos definidos por el usuario]]"
dg-publish: true
---
Un arreglo de elementos de tipo `char` puede ser declarado así:

```cpp
char v[6]; // Arreglo de 6 caracteres
```

Similarmente, un puntero puede ser declarado así:

```cpp
char* p; // Puntero a un carácter
```

En las declaraciones, `[]` significa “arreglo de” y `*` significa “puntero a”. Todos los arreglos tienen `0` como límite inferior, por lo que `v` tiene seis elementos, de `v[0]` a `v[5]`. El tamaño de un arreglo debe ser una expresión constante. Una variable puntero puede contener la dirección de un objeto del tipo adecuado:

```cpp
char*p = &v[3]; // p apunta al cuarto elemento de v
char x = *p; // *p es el objeto al que p está apuntando
```

En una expresión, el operador unario prefijo `*` significa “contenido de” y el operador unario prefijo `&` significa “dirección de”. Podemos representar gráficamente el resultado de esa definición inicializada:

![[Captura de pantalla 2025-08-15 a la(s) 6.32.54 p.m..png]]

Consideremos copiar diez elementos de un arreglo a otro:

```cpp
void func_copiar(){
	int v1[10] = {0,1,2,3,4,5,6,7,8,9};
	int v2[10]; // se convertirá en una copia de v1

	for(auto i=0; i!=10; ++i) // copiar elementos
		v2[i]=v1[i];
	// ...
}
```

Esta sentencia `for` se puede leer como: “inicializa `i` en cero; mientras `i` no sea `10`, copia el elemento `i` e incrementa `i`.” Cuando se aplica a una variable entera, el operador de incremento `++` simplemente suma 1. C++ también ofrece una sentencia `for` más simple, llamada sentencia `for` de rango, para bucles que recorren una secuencia de la manera más sencilla:

```cpp
void imprimir(){
	int v[]={0,1,2,3,4,5,6,7,8,9};

	for(auto x : v) // para cada x en v
		cout << x << '\n';

	for(auto x : {10,21,32,43,54,65})
		cout << x << '\n';
	// ...
}
```

La primera sentencia `for` de rango se puede leer como: “para cada elemento de `v`, desde el primero hasta el último, coloca una copia en `x` e imprímela”. Nótese que no es necesario especificar un límite del arreglo cuando lo inicializamos con una lista. La sentencia `for` de rango se puede usar para cualquier secuencia de elementos.

Si no quisiéramos copiar los valores de `v` en la variable `x`, sino simplemente que `x` se refiriera a un elemento, podríamos escribir:

```cpp
void incrementar() {
	int v[] = {0,1,2,3,4,5,6,7,8,9};

	for(auto& x : v)
		++x
	// ...
}
```

En una declaración, el operador unario como sufijo `&` significa “referencia a”. Una referencia es similar a un puntero, excepto que no es necesario usar un prefijo `*` para acceder al valor al que se refiere la referencia. Además, una referencia no puede ser cambiada para referirse a otro objeto después de su inicialización. Cuando se usan en declaraciones, los operadores (como `&`, `*` y `[]`) se llaman *operadores declaradores*.

```cpp
T a[n];   // T[n]: arreglo de n elementos de tipo T
T* p;     // T*: puntero a T
T& r;     // T&: referencia a T
T f(A);   // T(A): función que recibe un argumento de tipo A y devuelve un resultado de tipo T
```

Intentamos asegurarnos de que un puntero siempre apunte a un objeto, de manera que *desreferenciarlo* sea válido. Cuando no tenemos un objeto al que apuntar, o si necesitamos representar la noción de “no hay objeto disponible” (por ejemplo, al final de una lista), le damos al puntero el valor `nullptr` (“el puntero nulo”). Solo existe un `nullptr`, compartido por todos los tipos de punteros:

```cpp
double* pd = nullptr;
Link<Record>* Ist = nullptr; // puntero de un Enlace a un Registro
int x = nullptr; // error: nullptr es un puntero no un entero
```

A menudo es prudente verificar que un argumento puntero que se supone que apunta a algo, realmente apunte a algo:

```cpp
int contar_x(char* p, char x)  
// cuenta el número de ocurrencias de x en p[] 
// se asume que p apunta a un arreglo de char terminado en cero (o a nada) 
{     
	if (p == nullptr) return 0;     
	int count = 0;     
	for (; *p != 0; ++p)         
		if (*p == x) ++count;     
	return count; 
}
```

Nótese cómo podemos mover un puntero para que apunte al siguiente elemento de un arreglo usando `++` y que podemos omitir el inicializador en una sentencia `for` si no lo necesitamos.

La definición de `contar_x()` asume que el `char*` es una cadena estilo C es decir, que el puntero apunta a un arreglo de `char` terminado en cero.

En código más antiguo, típicamente se usa `0` o `NULL` en lugar de `nullptr`. Sin embargo, usar `nullptr` elimina la posible confusión entre enteros (como `0` o `NULL`) y punteros (como `nullptr`).