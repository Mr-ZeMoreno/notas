---
title: Clases
anterior: "[[Biblioteca/The C++ Programming Language - Bjarne Stroustrup/2 - Un Tour Por C++ - Lo Básico/3.1 - Estructuras]]"
siguiente: "[[Biblioteca/The C++ Programming Language - Bjarne Stroustrup/2 - Un Tour Por C++ - Lo Básico/3.3 - Enumeraciones]]"

---
Tener los datos especificados por separado de las operaciones sobre ellos tiene ventajas, como la capacidad de usar los datos de maneras arbitrarias. Sin embargo, se necesita una conexión más estrecha entre la representación y las operaciones para que un tipo definido por el usuario tenga todas las propiedades que se esperan de un “tipo real”.

En particular, a menudo queremos mantener la representación inaccesible para los usuarios, de modo que se facilite su uso, se garantice un uso consistente de los datos y podamos mejorar la representación más adelante.

Para lograr esto, debemos distinguir entre la interfaz de un tipo (que será usada por todos) y su implementación (que tiene acceso a los datos que de otro modo serían inaccesibles).

El mecanismo del lenguaje para esto se llama clase.  
Una clase se define con un conjunto de miembros, que pueden ser datos, funciones o tipos.  
La interfaz se define mediante los miembros públicos (`public`) de una clase, mientras que los miembros privados (`private`) solo son accesibles a través de esa interfaz.

Por ejemplo:

```cpp
class Vector {
public:
	Vector(int s) : elemento{new double[s]}, tmn{s}{} // constructor del Vector
	double& operator[](int i) { return elemento[i]; } // acceso a elemento: suscripción
	int tamano() { return tmn;}

private:
	double* elemento; // puntero a el elemento
	int tmn; // el número de elementos
};
```

Teniendo esto, podemos definir una variable de nuestro nuevo tipo `Vector`:

```cpp
Vector v(6); // un Vector con 6 elementos
```

Podemos ilustrar nuestro objeto `Vector` gráficamente:

![[Captura de pantalla 2025-08-15 a la(s) 9.15.51 p.m..png]]

Básicamente, el objeto `Vector` es un **“manejador”** que contiene un puntero a los elementos (`elemento`) más el número de elementos (`tamano`).

El número de elementos (6 en el ejemplo) puede variar de un objeto `Vector` a otro, y un objeto `Vector` puede tener un número diferente de elementos en distintos momentos.  
Sin embargo, el objeto `Vector` en sí **siempre tiene el mismo tamaño**.

Esta es la técnica básica para manejar cantidades variables de información en C++: un **manejador de tamaño fijo** que hace referencia a una **cantidad variable de datos “en otro lugar”** (por ejemplo, en el almacenamiento libre asignado mediante `new`).

Cómo diseñar y usar este tipo de objetos es el tema principal del Capítulo 3.

Aquí, la **representación de un Vector** (los miembros `elemento` y `tamano`) es accesible únicamente a través de la **interfaz proporcionada por los miembros públicos**: `Vector()`, `operator[]()` y `tamano()`.

El ejemplo `leer_y_sumar()` se simplifica a:

```cpp
double leer_y_sumar(int s){
	Vector v(s); // hace un vector de s cantidad de elementos
	for(int i=0; i!=v.tamano(); ++i)
		cin>>v[i]; // lee y carga en elementos

	double suma = 0;
	for(int i=0; i!=v.tamano(); ++i)
		suma+=v[i]; // toma la suma de los elementos
	return suma;
}
```

Una **“función”** que tiene el mismo nombre que su clase se llama **constructor**, es decir, una función que se utiliza para **construir objetos de una clase**.

Por lo tanto, el constructor `Vector()` reemplaza a `vector_init()`.

A diferencia de una función ordinaria, un constructor está garantizado para ser **utilizado al inicializar objetos de su clase**.  

Así, definir un constructor **elimina el problema de variables no inicializadas** para una clase.

`Vector(int)` define cómo se construyen los objetos de tipo `Vector`. En particular, indica que necesita un **entero** para hacerlo. Ese entero se usa como el **número de elementos**.

El constructor inicializa los miembros de `Vector` usando una **lista de inicialización de miembros**:

```cpp
:elemento{new double[s]}, tmn{s}
```

Es decir, primero inicializamos `elemento` con un puntero a `s` elementos de tipo `double` obtenidos del almacenamiento libre (**heap**). Luego, inicializamos `tmn` con `s`.

El acceso a los elementos se proporciona mediante una función de subíndice llamada `operator[]`. Esta función devuelve una **referencia** al elemento correspondiente (un `double&`).

La función `tamano()` se proporciona para que los usuarios puedan obtener el **número de elementos**.

Obviamente, la **gestión de errores** está completamente ausente, pero volveremos a eso en el futuro.

De manera similar, no proporcionamos un mecanismo para **devolver** el arreglo de `double` adquirido con `new`; más adelante veremos cómo usar un **destructor** para hacerlo de manera elegante.