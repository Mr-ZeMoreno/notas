---
anterior: "[[4.3.1 - Excepciones]]"
siguiente: "[[4.3.3 - Verificaciones estáticas]]"
dg-publish: true
---
El uso de **excepciones** para señalar accesos fuera de rango es un ejemplo de que una función **verifica sus argumentos y se niega a actuar** porque una suposición básica, o **precondición**, no se cumple.

Si hubiéramos especificado formalmente el operador subíndice de `Vector`, habríamos dicho algo como:

> "El índice debe estar en el rango `[0:tamano())`"

y eso es justamente lo que verificamos en nuestro `operator[]()`.

Cada vez que definimos una función, debemos considerar cuáles son sus **precondiciones** y, si es posible, **probarlas**.

Sin embargo, `operator[]()` opera sobre objetos de tipo `Vector` y nada de lo que hace tiene sentido si los miembros de `Vector` no tienen **valores razonables**.

En particular, dijimos:

> "`elemento` apunta a un arreglo de `tmn` de doble precisión"

pero eso solo lo indicamos en un comentario.

Una declaración de lo que **se asume que es verdadero para una clase** se llama **invariante de clase**, o simplemente **invariante**.
- Es tarea de un **constructor** establecer la invariante de su clase (para que las funciones miembro puedan confiar en ella).
- Es tarea de las **funciones miembro** asegurarse de que la invariante se cumpla cuando salen.

Desafortunadamente, nuestro constructor de `Vector` **solo hacía parcialmente su trabajo**. Inicializaba correctamente los miembros, pero **no verificaba que los argumentos tuviesen sentido**.

Por ejemplo:

```cpp
Vector v(-27); // Esto probablemente causará problemas
```

Una definición más adecuada sería:

```cpp
Vector::Vector(int s) {     
	if (s < 0) throw length_error{};     
	elemento = new double[s];     
	tmn = s; 
}
```

Aquí usamos la excepción de la biblioteca estándar `length_error` para **reportar un número de elementos no positivo**, porque algunas operaciones de la biblioteca estándar usan esta excepción para reportar problemas de este tipo.

Si `operator new` no puede asignar memoria, **lanza una `std::bad_alloc`**.

Ejemplo de manejo de estas excepciones:

```cpp
void test() {     
	try {         
		Vector v(-27);     
	} catch (std::length_error) { 
		// manejar tamaño negativo     
	} catch (std::bad_alloc) { 
		// manejar agotamiento de memoria     
	} 
}
```

También puedes **definir tus propias clases para ser usadas como excepciones**, y hacer que transporten información desde el punto donde se detecta el error hasta el punto donde se puede manejar.

A menudo, una función **no puede completar su tarea asignada** después de que se lanza una excepción.  
En ese caso, “manejar” la excepción simplemente significa **hacer alguna limpieza mínima local** y **volver a lanzar la excepción**.

La **noción de invariantes** es fundamental en el diseño de **clases**, y las **precondiciones** cumplen un papel similar en el diseño de **funciones**.

**Invariantes:**
- Nos ayudan a **entender con precisión lo que queremos**.
- Nos **obligan a ser específicos**, lo que nos da **mayores probabilidades de que nuestro código sea correcto** después de depuración y pruebas.

La noción de invariantes es la base de la gestión de **recursos** en C++, soportada por **constructores** y **destructores**.